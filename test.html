<html>

<head>
  <meta charset="utf-8" />
  <title>A-Frame Pano Sliders</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-extras/dist/aframe-extras.min.js"></script>

  <script>
    // ---------- Config: your input image pixel dimensions ----------
    const PANO_IMG_W = 16553; // px
    const PANO_IMG_H = 4092;  // px




    function cartesianToPolarRelativeToCamera(worldPos, cameraEl = document.querySelector('#head')) {
      const camPos = new THREE.Vector3();
      cameraEl.object3D.getWorldPosition(camPos);

      const dx = worldPos.x - camPos.x;
      const dz = worldPos.z - camPos.z;
      const dy = worldPos.y - camPos.y;

      const r = Math.hypot(dx, dz);
      const thetaDeg = Math.atan2(dx, dz) * 180 / Math.PI;
      const yOffset = dy;

      return { r, thetaDeg, yOffset };
    }



    // ---------- Simple slider (click/laser to set) ----------
    AFRAME.registerComponent('ui-slider', {
      schema: {
        min: { type: 'number', default: 0 }, max: { type: 'number', default: 1 }, value: { type: 'number', default: 0.5 },
        width: { type: 'number', default: 1.6 }, height: { type: 'number', default: 0.12 },
        on: { type: 'string', default: 'change' }, decimals: { type: 'int', default: 2 },
        step: { type: 'number', default: 0.05 }, hitpad: { type: 'number', default: 0.18 }
      },
      init() {
        const s = this.data, el = this.el;
        const hit = document.createElement('a-plane');
        hit.setAttribute('width', s.width + 2 * s.hitpad);
        hit.setAttribute('height', s.height + 2 * s.hitpad);
        hit.setAttribute('position', '0 0 0.0001');
        hit.setAttribute('material', 'color:#fff; opacity:0.001; transparent:true');
        hit.classList.add('ui-hitbox'); el.appendChild(hit); this.hit = hit;

        const bar = document.createElement('a-plane');
        bar.setAttribute('width', s.width); bar.setAttribute('height', s.height);
        bar.setAttribute('color', '#666'); bar.classList.add('ui-interactive');
        el.appendChild(bar); this.bar = bar;

        const track = document.createElement('a-plane');
        track.setAttribute('width', s.width); track.setAttribute('height', s.height * 0.4);
        track.setAttribute('color', '#999'); track.setAttribute('position', '0 0 0.001');
        el.appendChild(track);

        const thumb = document.createElement('a-circle');
        thumb.setAttribute('radius', s.height * 0.65); thumb.setAttribute('color', '#ddd');
        thumb.setAttribute('position', '0 0 0.002'); thumb.classList.add('ui-interactive');
        el.appendChild(thumb); this.thumb = thumb;

        const label = document.createElement('a-text');
        label.setAttribute('align', 'left'); label.setAttribute('color', '#fff');
        label.setAttribute('value', this._fmt(s.value));
        label.setAttribute('position', `${s.width / 2 + 0.12} 0 0.003`); label.setAttribute('width', '2');
        el.appendChild(label); this.label = label;

        this._hover = false;
        const on = () => this._hover = true, off = () => this._hover = false;
        [hit, bar, thumb].forEach(n => { n.addEventListener('mouseenter', on); n.addEventListener('mouseleave', off); });

        this._onWheel = (e) => {
          if (!this._hover) return; e.preventDefault();
          const dir = (e.deltaY > 0) ? -1 : 1; this._setValue(this.data.value + dir * this.data.step);
        };
        window.addEventListener('wheel', this._onWheel, { passive: false });

        const updateFromPoint = (ptWorld) => {
          const local = new THREE.Vector3().copy(ptWorld); this.bar.object3D.worldToLocal(local);
          const half = s.width / 2; const clampedX = Math.max(-half, Math.min(half, local.x));
          const t = (clampedX + half) / s.width; const val = s.min + t * (s.max - s.min); this._setValue(val);
        };
        const onClick = (e) => { if (!e.detail || !e.detail.intersection) return; updateFromPoint(e.detail.intersection.point); };
        hit.addEventListener('click', onClick); bar.addEventListener('click', onClick); thumb.addEventListener('click', onClick);

        this._applyThumbFromValue();
      },
      remove() { window.removeEventListener('wheel', this._onWheel); },
      _fmt(v) { return v.toFixed(Math.max(0, this.data.decimals | 0)); },
      _applyThumbFromValue() {
        const { min, max, value, width } = this.data; const t = (value - min) / (max - min);
        const x = -width / 2 + t * width; this.thumb.setAttribute('position', `${x} 0 0.002`);
        this.label.setAttribute('value', this._fmt(value));
      },
      _setValue(v) { const s = this.data; const c = Math.max(s.min, Math.min(s.max, v)); this.data.value = c; this._applyThumbFromValue(); this.el.emit(s.on, { value: c }); },
      setValue(v) { this._setValue(v); }
    });

    // ---------- Simple button ----------
    AFRAME.registerComponent('ui-button', {
      schema: { label: { type: 'string', default: 'Button' }, width: { type: 'number', default: 0.9 }, height: { type: 'number', default: 0.2 } },
      init() {
        const s = this.data, el = this.el;
        const hit = document.createElement('a-plane');
        hit.setAttribute('width', s.width); hit.setAttribute('height', s.height);
        hit.setAttribute('material', 'color:#888; opacity:0.95');
        hit.classList.add('ui-interactive', 'ui-hitbox'); el.appendChild(hit); this._hit = hit;
        const txt = document.createElement('a-text');
        txt.setAttribute('value', s.label); txt.setAttribute('align', 'center'); txt.setAttribute('color', '#fff');
        txt.setAttribute('width', s.width * 1.6); txt.setAttribute('position', '0 0 0.01'); el.appendChild(txt); this._txt = txt;
        hit.addEventListener('click', () => el.emit('clicked'));
      },
      update() {
        if (this._txt) this._txt.setAttribute('value', this.data.label);
        if (this._hit) { this._hit.setAttribute('width', this.data.width); this._hit.setAttribute('height', this.data.height); }
      }
    });

    // ---------- Menu toggle: spawn in front & face user ----------
    AFRAME.registerComponent('menu-toggle', {
      init() {
        this.panel = document.querySelector('#menuPanel');
        this.camera = document.querySelector('[camera]');
        this.visible = false;
        this.onKey = (e) => { if (e.code === 'Space') this.toggle(); };
        window.addEventListener('keydown', this.onKey);
        const right = document.querySelector('#rightHand');
        if (right) right.addEventListener('abuttondown', () => this.toggle());
      },
      remove() { window.removeEventListener('keydown', this.onKey); },
      toggle() {
        this.visible = !this.visible;
        if (this.visible) {
          const cam = this.camera.object3D; const pos = new THREE.Vector3(); const dir = new THREE.Vector3();
          cam.getWorldPosition(pos); cam.getWorldDirection(dir);
          const spawn = pos.clone().add(dir.multiplyScalar(-2));
          this.panel.setAttribute('position', `${spawn.x} ${spawn.y} ${spawn.z}`);
          this.panel.setAttribute('visible', true);
          requestAnimationFrame(() => {
            const panelPos = new THREE.Vector3(); const camPos = new THREE.Vector3();
            this.panel.object3D.getWorldPosition(panelPos); cam.getWorldPosition(camPos);
            const dx = camPos.x - panelPos.x, dz = camPos.z - panelPos.z;
            const yawDeg = Math.atan2(dx, dz) * 180 / Math.PI; const pitchDeg = -15;
            this.panel.setAttribute('rotation', `${pitchDeg} ${yawDeg} 0`);
          });
        } else { this.panel.setAttribute('visible', false); }
      }
    });

    // ---------- Locomotion manager (gamepad only so WASD is free) ----------
    AFRAME.registerComponent('locomotion-manager', {
      schema: { mode: { default: 'fly' } },
      init() { this.head = document.querySelector('#head'); this.mc = this.el.components['movement-controls']; this.setMode(this.data.mode); },
      setMode(mode) {
        if (mode === 'fly' && this.mc) {
          this.mc.pause();
          this.el.setAttribute('movement-controls', 'camera: #head; controls: gamepad; fly: true; speed: 2'); this.mc.play();
        }
        this.data.mode = mode; this.el.emit('locomotionmodechanged', { mode });
      },
      resetView() {
        this.el.setAttribute('position', '0 0 0'); this.el.setAttribute('rotation', '0 0 0');
        const head = this.head; if (head) {
          head.setAttribute('rotation', '0 0 0');
          const lc = head.components['look-controls']; if (lc && lc.yawObject && lc.pitchObject) { lc.yawObject.rotation.y = 0; lc.pitchObject.rotation.x = 0; }
        }
      }
    });

    // ---------- Wire menu buttons ----------
    AFRAME.registerComponent('menu-actions', {
      schema: { rig: { type: 'selector', default: '#rig' }, modeLabel: { type: 'selector', default: '#modeLabel' } },
      init() {
        const rig = this.data.rig, modeLabel = this.data.modeLabel;
        const resetBtn = this.el.querySelector('#btnReset'), modeBtn = this.el.querySelector('#btnMode');
        resetBtn.addEventListener('clicked', () => { rig.components['locomotion-manager'].resetView(); });
        modeBtn.addEventListener('clicked', () => { const lm = rig.components['locomotion-manager']; lm.setMode('fly'); if (modeLabel) modeLabel.setAttribute('value', 'Mode: Fly'); });
        if (modeLabel) modeLabel.setAttribute('value', 'Mode: Fly');
      }
    });

    // ---------- Pano controller (distance + theta -> height) ----------
    AFRAME.registerComponent('pano-controller', {
      init() {
        console.log('Pano controller init');

        this.pano = document.querySelector('#pano');
        this.distanceSlider = document.querySelector('#distanceSlider');
        this.thetaSlider = document.querySelector('#thetaSlider');
        this.heightReadout = document.querySelector('#heightReadout');
        const ready = (el, comp) => new Promise(res => {
          if (el && el.components && el.components[comp]) return res(el.components[comp]);
          const onInit = (e) => { if (e.detail.name === comp) { el.removeEventListener('componentinitialized', onInit); res(el.components[comp]); } };
          el.addEventListener('componentinitialized', onInit);
        });
        const nodeLoaded = (el) => new Promise(res => el.hasLoaded ? res() : el.addEventListener('loaded', res));
        Promise.all([
          nodeLoaded(this.pano),
          ready(this.distanceSlider, 'ui-slider'),
          ready(this.thetaSlider, 'ui-slider')
        ]).then(([_, dComp, tComp]) => {
          console.log('Pano controller ready');
          const initDistance = 5.0, initTheta = 180.0;
          dComp.setValue(initDistance); tComp.setValue(initTheta); this._apply(initDistance, initTheta);
          this.distanceSlider.addEventListener('distance', (e) => { const r = e.detail.value; const t = this.thetaSlider.components['ui-slider'].data.value; this._apply(r, t); });
          this.thetaSlider.addEventListener('theta', (e) => { const t = e.detail.value; const r = this.distanceSlider.components['ui-slider'].data.value; this._apply(r, t); });
        });
      },
      _apply(radiusM, thetaDeg) {
        console.log(`Pano controller apply: radius=${radiusM} m, theta=${thetaDeg} deg`);
        const thetaRad = thetaDeg * Math.PI / 180;
        const heightM = (PANO_IMG_H / PANO_IMG_W) * thetaRad * radiusM;
        this.pano.setAttribute('radius', radiusM);
        this.pano.setAttribute('theta-length', thetaDeg);
        this.pano.setAttribute('theta-start', 90 - (thetaDeg / 2));
        this.pano.setAttribute('height', heightM);
        this.pano.setAttribute('open-ended', true);
        this.pano.setAttribute('side', 'back');

        //upate the ghost as well
        const pano_ghost = document.querySelector('#pano_ghost');
        pano_ghost.setAttribute('radius', radiusM);
        



        if (this.heightReadout) { this.heightReadout.setAttribute('value', `Computed height: ${heightM.toFixed(3)} m`); }
      }
    });

    // ---------- Polar placement (WASD + Q/E) + auto-yaw rig toward pano ----------
    AFRAME.registerComponent('polar-placement', {
      schema: {
        target: { type: 'selector', default: '#pano' },
        r: { type: 'number', default: 0 },
        thetaDeg: { type: 'number', default: 0 },
        yOffset: { type: 'number', default: 0 },

        // Keyboard step sizes (per key press)
        rStep: { type: 'number', default: 0.2 },
        thetaStep: { type: 'number', default: 1 },
        // yStep: { type: 'number', default: 0.1 },

        // VR analog speeds (units/sec)
        rSpeed: { type: 'number', default: 1.5 },       // meters per second per full tilt
        thetaSpeed: { type: 'number', default: 60 },    // deg/sec per full tilt
        ySpeed: { type: 'number', default: 1.0 },       // meters/sec per full tilt
        deadzone: { type: 'number', default: 0.15 },

        showHUD: { type: 'boolean', default: true },
        hudId: { type: 'string', default: 'polarHUD' },
        faceRig: { type: 'boolean', default: true }
      },


      init() {
        this.head = document.querySelector('#head');

        // If WebXR hands have real gamepads, we’ll know on first tick
        this._lastT = performance.now();

        // axes state
        this.axesL = { x: 0, y: 0 };
        this.axesR = { x: 0, y: 0 };
        this.bHeld = false;




        // ----- Keyboard controls callback function -----
        this.onKey = (e) => {
          this.data.dx = 0
          this.data.dz = 0
          this.data.dy = 0
          this.data.drot = 0
          let used = false;

          // // dynamic scaling based on distance (closer -> slower)
          // // const minSpeedScale = 0.01;          // never go below 20% speed
          // // const maxSpeedScale = 10.0;          // normal at far distance
          // const maxRange = .025;         // start scaling below this distance

          // //speed is linear from max of 10% radius at 0 to 0 at DIAMTER

          // let panoDiameter = 2* d.target.getAttribute('radius');
          // let maxSpeed = .25
          // let scale = maxSpeed * (1 - d.r / panoDiameter) * panoDiameter
          // // console.log("scale is", scale);

          // // slower turning (A/D)
          // const thetaStepScaled = d.thetaStep * (1 - d.r / panoDiameter); //similar scale for the theta
          // // console.log("theta step scaled is", thetaStepScaled);

          // //same scaling for up down
          // const yStepScaled = 1 * (1 - d.r / panoDiameter);

          switch (e.code) {
            case 'KeyW':
              this.data.dz = -1
              used = true;
              break;

            case 'KeyS':
              this.data.dz = -1
              used = true;
              break;

            case 'KeyD':
              this.data.drot = -1
              used = true;
              break;
            case 'KeyA':
              this.data.drot = 1
              used = true;
              break;
            case 'KeyE':
              this.data.dy = 1
              used = true;
              break;
            case 'KeyQ':
              this.data.dy = -1
              used = true;
              break;
          }


          // //don't let r be greater than the actual DIAMETER of the pano
          // if (d.r >= 2*d.target.getAttribute('radius')) {
          //   // console.log(`Clamping r from ${d.r} to pano radius`);
          //   d.r = d.target.getAttribute('radius') * .95;
          // }
          // //don't let r be less than 0.01
          // if (d.r < 0.01) {
          //   // console.log(`Clamping r from ${d.r} to 0.01`);
          //   d.r = 0.01;
          // }

          // //don't let thetaDeg abs beyond half the fov of the pano
          // const panoThetaLength = d.target.getAttribute('theta-length');
          // console.log("pano theta length is", panoThetaLength);
          // const halfFov = panoThetaLength / 2;
          // if (Math.abs(180-d.thetaDeg) > halfFov) {
          //   // console.log(`Clamping thetaDeg from ${d.thetaDeg} to ${halfFov}`);
          //   d.thetaDeg = Math.sign(d.thetaDeg) * halfFov;
          // }


          //if a key was pressed, apply the change
          if (used) {
            // console.log(`Polar placement key: r=${d.r.toFixed(2)}, theta=${d.thetaDeg.toFixed(1)}, yOffset=${d.yOffset.toFixed(2)}`);
            console.log(`Key press detected: dz=${this.data.dz}, dy=${this.data.dy}, drot=${this.data.drot}`);
            e.preventDefault();
            e.stopPropagation();
            this.apply();
          }
        };

        window.addEventListener('keydown', this.onKey);




        // First placement
        this.apply();
        this._lastT = performance.now();
      },

      remove() {
        window.removeEventListener('keydown', this.onKey);
      },


      //applies the position change
      apply() {

        //t is the target- I believe the camera
        const t = this.data.target; if (!t || !this.head) return;
        //print all info on the target
        // console.log('Polar placement apply to target:', t);
        window.t = t;


        let { r, thetaDeg, yOffset } = this.data;

        // console.log(`Applying polar placement: r=${r}, theta=${thetaDeg}, yOffset=${yOffset}`);
        const thetaRad = THREE.MathUtils.degToRad(180-thetaDeg);

        // Place relative to camera position
        // const camPos = new THREE.Vector3();

        // //I think that head is the achor entity with id head
        // //ray origin is the mouse so I think this is the camera?
        // //then what is t?


        // //but anyway, here we are getting the world position of the camera
        // //and storing it in camPos
        // this.head.object3D.getWorldPosition(camPos);
        // camera position is 0 1.6 0 

        //compute x,y,z from the radius and theta
        //y (height) is separate
        // const x = r * Math.sin(thetaRad);
        // const z = r * Math.cos(thetaRad);
        // const y = yOffset;



        //
        // this.data.dx = 0
        // this.data.dz = 0
        // this.data.dy = 0
        // this.data.drot = 0



        //I don't understand why we are adding here
        //anyway it works out
        // get current position x y z and rotation
        let currentPos = t.getAttribute('position');
        let currentRot = t.getAttribute('rotation');

        window.test = window.test || {};
        window.test.currentPos = currentPos;
        window.test.currentRot = currentRot;

        // compute new position based on current position and deltas
        let newPos = {
          x: currentPos.x + this.data.dx,
          y: currentPos.y + this.data.dy,
          z: currentPos.z + this.data.dz
        };
        let newRotY = currentRot.y + this.data.drot;


        // t.setAttribute('position', `${newPos.x} ${newPos.y} ${newPos.z}`);
        // //also need to set it's rotation so it faces the camera
        // t.setAttribute('rotation', `0 ${newRotY} 0`);

        console.log(`New position: x=${newPos.x.toFixed(2)}, y=${newPos.y.toFixed(2)}, z=${newPos.z.toFixed(2)}, rotY=${newRotY.toFixed(1)}`);

        // // Yaw the rig toward the pano (VR-friendly; doesn't fight head)
        // if (this.data.faceRig && this.rig) {
        //   const rigPos = new THREE.Vector3(); this.rig.object3D.getWorldPosition(rigPos);
        //   const dx = newPos.x - rigPos.x, dz = newPos.z - rigPos.z;
        //   const yawDeg = Math.atan2(dx, dz) * 180 / Math.PI;
        //   const rot = this.rig.getAttribute('rotation') || { x: 0, y: 0, z: 0 };
        //   this.rig.setAttribute('rotation', { x: rot.x, y: yawDeg, z: rot.z });
        // }

        // HUD
        // if (this.data.showHUD){
        //   const hud = document.getElementById(this.data.hudId);
        //   if (hud) hud.setAttribute('value',
        //     `r: ${r.toFixed(2)} m   θ: ${thetaDeg.toFixed(1)}°   y: ${yOffset.toFixed(2)} m`);
        // }
      }
    });
  </script>
</head>

<body>
  <a-scene>
    <!-- RIG (gamepad locomotion only, so WASD is free for polar placement) -->
    <a-entity id="rig" movement-controls="camera: #head; controls: keyboard; fly: true; speed: 2" locomotion-manager
      menu-toggle pano-controller
      polar-placement="target: #pano; hudId: polarHUD; r: 0; thetaDeg: 0; yOffset: 0; faceRig: true">

      <!-- Camera -->
      <a-entity id="head" camera look-controls cursor="rayOrigin: mouse; fuse: false"
        raycaster="objects: .ui-interactive, .ui-hitbox" position="0 1 1"></a-entity>

      <!-- Hands / lasers -->
      <a-entity id="leftHand" laser-controls="hand: left" raycaster="objects: .ui-interactive, .ui-hitbox"></a-entity>
      <a-entity id="rightHand" laser-controls="hand: right" raycaster="objects: .ui-interactive, .ui-hitbox"></a-entity>
    </a-entity>

    <!-- Optional HUD for polar controls
    <a-text id="polarHUD" value="r: 0.00 m   θ: 0.0°   y: 0.00 m" color="#fff" align="center" width="2.6"
      position="0 1.3 -1.2"></a-text> -->

    <!-- Example still image -->
    <!-- <a-image src="photos/IMG_20251024_0001_04.jpg" position="0 1.7 -3" width="0.6" height="0.87"></a-image> -->


    <!-- for reference a sphere at the center-->
    <!-- <a-sphere position="0 0 0" radius="0.25" color="blue"></a-sphere> -->




    <a-assets>
      <img id="sky" src="photos/sky.jpeg">
    </a-assets>
    <a-sky src="#sky"></a-sky>



    <a-scene>
      <!-- z axis -->
      <a-cylinder position="0 0 0" rotation="90 0 0" radius="0.02" height="100" color="blue"></a-cylinder>
      <!-- x axis -->
      <a-cylinder position="0 0 0" rotation="0 0 90" radius="0.02" height="100" color="red"></a-cylinder>

      <!-- arrowhead -->
      <!-- <a-cone position="0 0 0" radius-bottom="0.05" radius-top="0" height="0.1" color="blue"
        rotation="90 180 0"></a-cone> -->
    </a-scene>



    <!-- Cylindrical panorama WITH ID -->
    <a-cylinder id="pano" position="0 0 -10" rotation="0 90 0" radius="5" height="3" theta-length="180" open-ended="true"
      side="back" src="photos/IMG_0466-Pano.jpg">
    </a-cylinder>

    <!-- for debug, a 360 degree cylinder for reference-->
     <a-cylinder id="pano_ghost" position="0 0 -10" rotation="0 90 0" radius="5" height=".1" theta-length="360" open-ended="false"
      side="back" color="grey" opacity="0.2">
    </a-cylinder>

    <!-- for debug, a dot at the "position" of the pano-->
    <a-sphere id="pano_position_marker" position="0 0 -10" radius="0.1" color="red"></a-sphere>


    <!-- MENU PANEL (toggled with Space/A) -->
    <a-entity id="menuPanel" visible="false" geometry="primitive: plane; width: 1.8; height: 1.2"
      material="color: #666; opacity: 0.95" menu-actions="rig: #rig; modeLabel: #modeLabel">

      <a-text value="Panorama Settings" color="#fff" align="center" position="0 0.50 0.01" width="2.2"></a-text>

      <!-- Distance (radius) slider -->
      <a-text value="Distance (m)" color="#fff" align="left" position="-0.85 0.32 0.01" width="1.5"></a-text>
      <a-entity id="distanceSlider"
        ui-slider="min: 1; max: 50; value: 5; width: 1.8; height: 0.14; on: distance; decimals: 2; step: 0.1; hitpad: 0.25"
        position="0 0.22 0.01"></a-entity>

      <!-- Theta slider -->
      <a-text value="Theta (deg)" color="#fff" align="left" position="-0.85 0.02 0.01" width="1.5"></a-text>
      <a-entity id="thetaSlider"
        ui-slider="min: 30; max: 340; value: 180; width: 1.8; height: 0.14; on: theta; decimals: 0; step: 1; hitpad: 0.25"
        position="0 -0.08 0.01"></a-entity>

      <!-- Computed height readout -->
      <a-text id="heightReadout" value="Computed height: —" color="#ddd" align="center" width="1.8"
        position="0 -0.26 0.01"></a-text>

      <!-- Mode label -->
      <a-text id="modeLabel" value="Mode: Fly" color="#fff" align="center" width="2" position="0 -0.02 0.01"></a-text>

      <!-- Buttons row -->
      <a-entity position="0 -0.38 0.01">
        <a-entity id="btnReset" ui-button="label: Reset View; width: 0.8; height: 0.2" position="-0.45 0 0"></a-entity>
        <a-entity id="btnMode" ui-button="label: Locomotion: Fly; width: 0.95; height: 0.2"
          position="0.55 0 0"></a-entity>
      </a-entity>

      <a-text value="Space / A: Toggle menu • Click or point to interact" color="#ddd" align="center" width="1.8"
        position="0 -0.56 0.01"></a-text>
    </a-entity>
  </a-scene>
</body>

</html>