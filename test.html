<html>

<head>
  <meta charset="utf-8" />
  <title>A-Frame Pano Sliders</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-extras/dist/aframe-extras.min.js"></script>

  <script>
    // ---------- Config: your input image pixel dimensions ----------
    const PANO_IMG_W = 16553; // px
    const PANO_IMG_H = 4092;  // px

    // ---------- Simple slider (click/laser to set) ----------
    AFRAME.registerComponent('ui-slider', {
      schema: {
        min: { type: 'number', default: 0 }, max: { type: 'number', default: 1 }, value: { type: 'number', default: 0.5 },
        width: { type: 'number', default: 1.6 }, height: { type: 'number', default: 0.12 },
        on: { type: 'string', default: 'change' }, decimals: { type: 'int', default: 2 },
        step: { type: 'number', default: 0.05 }, hitpad: { type: 'number', default: 0.18 }
      },
      init() {
        const s = this.data, el = this.el;
        const hit = document.createElement('a-plane');
        hit.setAttribute('width', s.width + 2 * s.hitpad);
        hit.setAttribute('height', s.height + 2 * s.hitpad);
        hit.setAttribute('position', '0 0 0.0001');
        hit.setAttribute('material', 'color:#fff; opacity:0.001; transparent:true');
        hit.classList.add('ui-hitbox'); el.appendChild(hit); this.hit = hit;

        const bar = document.createElement('a-plane');
        bar.setAttribute('width', s.width); bar.setAttribute('height', s.height);
        bar.setAttribute('color', '#666'); bar.classList.add('ui-interactive');
        el.appendChild(bar); this.bar = bar;

        const track = document.createElement('a-plane');
        track.setAttribute('width', s.width); track.setAttribute('height', s.height * 0.4);
        track.setAttribute('color', '#999'); track.setAttribute('position', '0 0 0.001');
        el.appendChild(track);

        const thumb = document.createElement('a-circle');
        thumb.setAttribute('radius', s.height * 0.65); thumb.setAttribute('color', '#ddd');
        thumb.setAttribute('position', '0 0 0.002'); thumb.classList.add('ui-interactive');
        el.appendChild(thumb); this.thumb = thumb;

        const label = document.createElement('a-text');
        label.setAttribute('align', 'left'); label.setAttribute('color', '#fff');
        label.setAttribute('value', this._fmt(s.value));
        label.setAttribute('position', `${s.width / 2 + 0.12} 0 0.003`); label.setAttribute('width', '2');
        el.appendChild(label); this.label = label;

        this._hover = false;
        const on = () => this._hover = true, off = () => this._hover = false;
        [hit, bar, thumb].forEach(n => { n.addEventListener('mouseenter', on); n.addEventListener('mouseleave', off); });

        this._onWheel = (e) => {
          if (!this._hover) return; e.preventDefault();
          const dir = (e.deltaY > 0) ? -1 : 1; this._setValue(this.data.value + dir * this.data.step);
        };
        window.addEventListener('wheel', this._onWheel, { passive: false });

        const updateFromPoint = (ptWorld) => {
          const local = new THREE.Vector3().copy(ptWorld); this.bar.object3D.worldToLocal(local);
          const half = s.width / 2; const clampedX = Math.max(-half, Math.min(half, local.x));
          const t = (clampedX + half) / s.width; const val = s.min + t * (s.max - s.min); this._setValue(val);
        };
        const onClick = (e) => { if (!e.detail || !e.detail.intersection) return; updateFromPoint(e.detail.intersection.point); };
        hit.addEventListener('click', onClick); bar.addEventListener('click', onClick); thumb.addEventListener('click', onClick);

        this._applyThumbFromValue();
      },
      remove() { window.removeEventListener('wheel', this._onWheel); },
      _fmt(v) { return v.toFixed(Math.max(0, this.data.decimals | 0)); },
      _applyThumbFromValue() {
        const { min, max, value, width } = this.data; const t = (value - min) / (max - min);
        const x = -width / 2 + t * width; this.thumb.setAttribute('position', `${x} 0 0.002`);
        this.label.setAttribute('value', this._fmt(value));
      },
      _setValue(v) { const s = this.data; const c = Math.max(s.min, Math.min(s.max, v)); this.data.value = c; this._applyThumbFromValue(); this.el.emit(s.on, { value: c }); },
      setValue(v) { this._setValue(v); }
    });

    // ---------- Simple button ----------
    AFRAME.registerComponent('ui-button', {
      schema: { label: { type: 'string', default: 'Button' }, width: { type: 'number', default: 0.9 }, height: { type: 'number', default: 0.2 } },
      init() {
        const s = this.data, el = this.el;
        const hit = document.createElement('a-plane');
        hit.setAttribute('width', s.width); hit.setAttribute('height', s.height);
        hit.setAttribute('material', 'color:#888; opacity:0.95');
        hit.classList.add('ui-interactive', 'ui-hitbox'); el.appendChild(hit); this._hit = hit;
        const txt = document.createElement('a-text');
        txt.setAttribute('value', s.label); txt.setAttribute('align', 'center'); txt.setAttribute('color', '#fff');
        txt.setAttribute('width', s.width * 1.6); txt.setAttribute('position', '0 0 0.01'); el.appendChild(txt); this._txt = txt;
        hit.addEventListener('click', () => el.emit('clicked'));
      },
      update() {
        if (this._txt) this._txt.setAttribute('value', this.data.label);
        if (this._hit) { this._hit.setAttribute('width', this.data.width); this._hit.setAttribute('height', this.data.height); }
      }
    });

    // ---------- Menu toggle: spawn in front & face user ----------
    AFRAME.registerComponent('menu-toggle', {
      init() {
        this.panel = document.querySelector('#menuPanel');
        this.camera = document.querySelector('[camera]');
        this.visible = false;
        this.onKey = (e) => { if (e.code === 'Space') this.toggle(); };
        window.addEventListener('keydown', this.onKey);
        const right = document.querySelector('#rightHand');
        if (right) right.addEventListener('abuttondown', () => this.toggle());
      },
      remove() { window.removeEventListener('keydown', this.onKey); },
      toggle() {
        this.visible = !this.visible;
        if (this.visible) {
          const cam = this.camera.object3D; const pos = new THREE.Vector3(); const dir = new THREE.Vector3();
          cam.getWorldPosition(pos); cam.getWorldDirection(dir);
          const spawn = pos.clone().add(dir.multiplyScalar(-2));
          this.panel.setAttribute('position', `${spawn.x} ${spawn.y} ${spawn.z}`);
          this.panel.setAttribute('visible', true);
          requestAnimationFrame(() => {
            const panelPos = new THREE.Vector3(); const camPos = new THREE.Vector3();
            this.panel.object3D.getWorldPosition(panelPos); cam.getWorldPosition(camPos);
            const dx = camPos.x - panelPos.x, dz = camPos.z - panelPos.z;
            const yawDeg = Math.atan2(dx, dz) * 180 / Math.PI; const pitchDeg = -15;
            this.panel.setAttribute('rotation', `${pitchDeg} ${yawDeg} 0`);
          });
        } else { this.panel.setAttribute('visible', false); }
      }
    });

    // ---------- Locomotion manager (gamepad only so WASD is free) ----------
    // AFRAME.registerComponent('locomotion-manager', {
    //   schema: { mode: { default: 'fly' } },
    //   init() { this.head = document.querySelector('#head'); this.mc = this.el.components['movement-controls']; this.setMode(this.data.mode); },
    //   setMode(mode) {
    //     if (mode === 'fly' && this.mc) {
    //       this.mc.pause();
    //       this.el.setAttribute('movement-controls', 'camera: #head; controls: gamepad; fly: true; speed: 2'); this.mc.play();
    //     }
    //     this.data.mode = mode; this.el.emit('locomotionmodechanged', { mode });
    //   },
    //   resetView() {
    //     this.el.setAttribute('position', '0 0 0'); this.el.setAttribute('rotation', '0 0 0');
    //     const head = this.head; if (head) {
    //       head.setAttribute('rotation', '0 0 0');
    //       const lc = head.components['look-controls']; if (lc && lc.yawObject && lc.pitchObject) { lc.yawObject.rotation.y = 0; lc.pitchObject.rotation.x = 0; }
    //     }
    //   }
    // });

    // ---------- Wire menu buttons ----------
    AFRAME.registerComponent('menu-actions', {
      schema: { rig: { type: 'selector', default: '#rig' }, modeLabel: { type: 'selector', default: '#modeLabel' } },
      init() {
        const rig = this.data.rig, modeLabel = this.data.modeLabel;
        const resetBtn = this.el.querySelector('#btnReset'), modeBtn = this.el.querySelector('#btnMode');
        // resetBtn.addEventListener('clicked', () => { rig.components['locomotion-manager'].resetView(); });
        // modeBtn.addEventListener('clicked', () => { const lm = rig.components['locomotion-manager']; lm.setMode('fly'); if (modeLabel) modeLabel.setAttribute('value', 'Mode: Fly'); });
        if (modeLabel) modeLabel.setAttribute('value', 'Mode: Fly');
      }
    });

    // ---------- Pano controller (distance + theta -> height) ----------
    // listens to sliders and updates pano attributes for radius and theta-length
    AFRAME.registerComponent('pano-controller', {
      init() {
        console.log('Pano controller init');

        this.pano = document.querySelector('#pano');
        this.distanceSlider = document.querySelector('#distanceSlider');
        this.thetaSlider = document.querySelector('#thetaSlider');
        this.heightReadout = document.querySelector('#heightReadout');
        const ready = (el, comp) => new Promise(res => {
          if (el && el.components && el.components[comp]) return res(el.components[comp]);
          const onInit = (e) => { if (e.detail.name === comp) { el.removeEventListener('componentinitialized', onInit); res(el.components[comp]); } };
          el.addEventListener('componentinitialized', onInit);
        });
        const nodeLoaded = (el) => new Promise(res => el.hasLoaded ? res() : el.addEventListener('loaded', res));
        Promise.all([
          nodeLoaded(this.pano),
          ready(this.distanceSlider, 'ui-slider'),
          ready(this.thetaSlider, 'ui-slider')
        ]).then(([_, dComp, tComp]) => {
          console.log('Pano controller ready');
          const initDistance = 5.0, initTheta = 180.0;
          dComp.setValue(initDistance); tComp.setValue(initTheta); this._apply(initDistance, initTheta);
          this.distanceSlider.addEventListener('distance', (e) => { const r = e.detail.value; const t = this.thetaSlider.components['ui-slider'].data.value; this._apply(r, t); });
          this.thetaSlider.addEventListener('theta', (e) => { const t = e.detail.value; const r = this.distanceSlider.components['ui-slider'].data.value; this._apply(r, t); });
        });
      },
      _apply(radiusM, thetaDeg) {
        console.log(`Pano controller apply: radius=${radiusM} m, theta=${thetaDeg} deg`);
        const thetaRad = thetaDeg * Math.PI / 180;
        const heightM = (PANO_IMG_H / PANO_IMG_W) * thetaRad * radiusM;
        this.pano.setAttribute('radius', radiusM);
        this.pano.setAttribute('theta-length', thetaDeg);
        this.pano.setAttribute('theta-start', 90 - (thetaDeg / 2));
        this.pano.setAttribute('height', heightM);
        this.pano.setAttribute('open-ended', true);
        this.pano.setAttribute('side', 'back');

        //upate the ghost as well
        const pano_ghost = document.querySelector('#pano_ghost');
        pano_ghost.setAttribute('radius', radiusM);




        if (this.heightReadout) { this.heightReadout.setAttribute('value', `Computed height: ${heightM.toFixed(3)} m`); }
      }
    });

    // ---------- Polar placement (WASD + Q/E) + auto-yaw rig toward pano ----------
    // listens to keyboard input to move the pano
    // ---------- Polar placement (keyboard + Quest sticks) ----------
    AFRAME.registerComponent('polar-placement', {
      schema: {
        target: { type: 'selector', default: '#pano' },
        r: { type: 'number', default: 0 },
        thetaDeg: { type: 'number', default: 0 },
        yOffset: { type: 'number', default: 0 },

        //idk if these do anything important
        hudId: { type: 'string', default: 'polarHUD' },
        faceRig: { type: 'boolean', default: true }
      },


      init() {
        this.head = document.querySelector('#head');

        // ----- Keyboard controls callback function -----
        this.onKey = (e) => {
          this.data.dx = 0
          this.data.dz = 0
          this.data.dy = 0
          this.data.drot = 0
          let used = false;

          switch (e.code) {
            case 'KeyW':
              this.data.dz = 1
              used = true;
              break;
            case 'KeyS':
              this.data.dz = -1
              used = true;
              break;
            case 'KeyD':
              this.data.drot = -1
              used = true;
              break;
            case 'KeyA':
              this.data.drot = 1
              used = true;
              break;
            case 'KeyE':
              this.data.dy = -.25
              used = true;
              break;
            case 'KeyQ':
              this.data.dy = .25
              used = true;
              break;
          }

          //if a key was pressed, apply the change
          if (used) {
            // console.log(`Key press detected: dz=${this.data.dz}, dy=${this.data.dy}, drot=${this.data.drot}`);
            e.preventDefault();
            e.stopPropagation();
            this.apply();
          }
        };

        window.addEventListener('keydown', this.onKey);
        // First placement
        this.apply();
      },

      remove() {
        window.removeEventListener('keydown', this.onKey);
      },


      //applies the position change to the pano
      apply() {
        //t is the target- I believe the camera
        const t = this.data.target; if (!t || !this.head) return;
        //print all info on the target
        window.t = t;

        // get current position x y z and rotation
        let currentPos = t.getAttribute('position');
        let currentRot = t.getAttribute('rotation');

        // compute new position based on current position and deltas
        let newPos = {
          x: currentPos.x + this.data.dx,
          y: currentPos.y + this.data.dy,
          z: currentPos.z + this.data.dz
        };
        let newRotY = currentRot.y + this.data.drot;


        //don't let z be greater than the radius of the pano
        const panoRadius = t.getAttribute('radius');
        if (newPos.z > panoRadius - 0.05) {
          newPos.z = panoRadius - 0.05;
        }

        // if any is NaN ignore the update - happens on first load
        if (isNaN(newPos.x) || isNaN(newPos.y) || isNaN(newPos.z) || isNaN(newRotY)) {
          console.warn('Polar placement: computed NaN position or rotation, ignoring update');
          return;
        }


        t.setAttribute('position', `${newPos.x} ${newPos.y} ${newPos.z}`);
        //also need to set it's rotation so it faces the camera
        t.setAttribute('rotation', `0 ${newRotY} 0`);

        //also update the pano position marker and pano_ghost
        const pano_marker = document.querySelector('#pano_position_marker');
        pano_marker.setAttribute('position', `${newPos.x} ${newPos.y} ${newPos.z}`);
        const pano_ghost = document.querySelector('#pano_ghost');
        pano_ghost.setAttribute('position', `${newPos.x} ${newPos.y} ${newPos.z}`);


        console.log(`New position: x=${newPos.x.toFixed(2)}, y=${newPos.y.toFixed(2)}, z=${newPos.z.toFixed(2)}, rotY=${newRotY.toFixed(1)}`);

      }
    });



    // ---------- Pano joystick controls (Meta Quest thumbsticks) ----------
    AFRAME.registerComponent('pano-joystick-controls', {
      schema: {
        target: { type: 'selector', default: '#pano' }
      },

      init() {
        this.target = this.data.target;
        this.deadzone = 0.15;
        this.moveSpeed = 2.0;     // m/s forward/back
        this.verticalSpeed = 1.0; // m/s up/down
        this.rotateSpeed = 60.0;  // deg/s yaw

        this.leftStick = { x: 0, y: 0 };
        this.rightStick = { x: 0, y: 0 };

        const leftHand = document.querySelector('#leftHand');
        const rightHand = document.querySelector('#rightHand');

        if (leftHand) {
          leftHand.addEventListener('thumbstickmoved', (evt) => {
            // evt.detail = {x, y}
            this.leftStick.x = evt.detail.x || 0;
            this.leftStick.y = evt.detail.y || 0;
          });
        }

        if (rightHand) {
          rightHand.addEventListener('thumbstickmoved', (evt) => {
            this.rightStick.x = evt.detail.x || 0;
            this.rightStick.y = evt.detail.y || 0;
          });
        }

        console.log('pano-joystick-controls initialized');
      },

      tick(time, dt) {
        if (!this.target) return;

        const pos = this.target.getAttribute('position');
        const rot = this.target.getAttribute('rotation');
        if (!pos || !rot) return;

        const deltaSec = dt / 1000;

        let changed = false;

        // --- LEFT STICK: forward/back + rotate (W/S + A/D) ---
        const lx = this.leftStick.x;
        const ly = this.leftStick.y;

        // forward/back on z
        if (Math.abs(ly) > this.deadzone) {
          // stick up (y < 0) -> move pano toward camera (positive z)
          pos.z += -ly * this.moveSpeed * deltaSec;
          changed = true;
        }

        // yaw rotation
        if (Math.abs(lx) > this.deadzone) {
          // stick right (x > 0) -> rotate pano right (negative yaw)
          rot.y += -lx * this.rotateSpeed * deltaSec;
          changed = true;
        }

        // --- RIGHT STICK: up/down (Q/E) ---
        const ry = this.rightStick.y;

        if (Math.abs(ry) > this.deadzone) {
          // stick up (y < 0) -> move pano up
          pos.y += -ry * this.verticalSpeed * deltaSec;
          changed = true;
        }

        if (!changed) return;

        // Clamp z so the pano doesn't pass "through" itself
        const panoRadius = this.target.getAttribute('radius');
        if (panoRadius != null && !isNaN(panoRadius)) {
          if (pos.z > panoRadius - 0.05) {
            pos.z = panoRadius - 0.05;
          }
        }

        if (
          isNaN(pos.x) || isNaN(pos.y) || isNaN(pos.z) ||
          isNaN(rot.y)
        ) {
          console.warn('pano-joystick-controls: NaN position/rotation, ignoring update');
          return;
        }

        this.target.setAttribute('position', pos);
        this.target.setAttribute('rotation', `0 ${rot.y} 0`);

        // Keep your markers in sync
        const pano_marker = document.querySelector('#pano_position_marker');
        if (pano_marker) pano_marker.setAttribute('position', pos);

        const pano_ghost = document.querySelector('#pano_ghost');
        if (pano_ghost) pano_ghost.setAttribute('position', pos);

        // Uncomment if you want spammy logs:
        // console.log(`Pano (sticks): x=${pos.x.toFixed(2)}, y=${pos.y.toFixed(2)}, z=${pos.z.toFixed(2)}, rotY=${rot.y.toFixed(1)}`);
      }
    });


  </script>
</head>

<body>
  <a-scene>
    <!-- RIG (gamepad locomotion only, so WASD is free for polar placement) -->
    <a-entity id="rig" menu-toggle pano-controller
      polar-placement="target: #pano; hudId: polarHUD; r: 0; thetaDeg: 0; yOffset: 0; faceRig: true"
      pano-joystick-controls="target: #pano">


      <!-- Camera -->
      <a-entity id="head" camera look-controls cursor="rayOrigin: mouse; fuse: false"
        raycaster="objects: .ui-interactive, .ui-hitbox" position="0 1 1"></a-entity>

      <!-- Hands / lasers -->
      <a-entity id="leftHand" meta-touch-controls="hand: left" laser-controls="hand: left"
        raycaster="objects: .ui-interactive, .ui-hitbox"></a-entity>

      <a-entity id="rightHand" meta-touch-controls="hand: right" laser-controls="hand: right"
        raycaster="objects: .ui-interactive, .ui-hitbox"></a-entity>



    </a-entity>



    <a-assets>
      <img id="sky" src="photos/sky.jpeg">
    </a-assets>
    <a-sky src="#sky"></a-sky>



    <!-- Axes for reference -->
    <a-scene>
      <!-- z axis -->
      <a-cylinder position="0 0 0" rotation="90 0 0" radius="0.02" height="100" color="blue"></a-cylinder>
      <!-- x axis -->
      <a-cylinder position="0 0 0" rotation="0 0 90" radius="0.02" height="100" color="red"></a-cylinder>
    </a-scene>



    <!-- Cylindrical panorama WITH ID -->
    <a-cylinder id="pano" position="0 0 -10" rotation="0 90 0" radius="5" height="3" theta-length="180"
      open-ended="true" side="back" src="photos/IMG_0466-Pano.jpg">
    </a-cylinder>

    <!-- for debug, a 360 degree cylinder for reference - make opactiy >0 to turn on -->
    <a-cylinder id="pano_ghost" position="0 0 -10" rotation="0 90 0" radius="5" height=".1" theta-length="360"
      open-ended="false" side="back" color="grey" opacity="0">
    </a-cylinder>

    <!-- for debug, a dot at the "position" of the pano-->
    <a-sphere id="pano_position_marker" position="0 0 -10" radius="0.1" color="red" opactiy="0"></a-sphere>


    <!-- MENU PANEL (toggled with Space/A) -->
    <a-entity id="menuPanel" visible="false" geometry="primitive: plane; width: 1.8; height: 1.2"
      material="color: #666; opacity: 0.95" menu-actions="rig: #rig; modeLabel: #modeLabel">

      <a-text value="Panorama Settings" color="#fff" align="center" position="0 0.50 0.01" width="2.2"></a-text>

      <!-- Distance (radius) slider -->
      <a-text value="Distance (m)" color="#fff" align="left" position="-0.85 0.32 0.01" width="1.5"></a-text>
      <a-entity id="distanceSlider"
        ui-slider="min: 1; max: 50; value: 5; width: 1.8; height: 0.14; on: distance; decimals: 2; step: 0.1; hitpad: 0.25"
        position="0 0.22 0.01"></a-entity>

      <!-- Theta slider -->
      <a-text value="Theta (deg)" color="#fff" align="left" position="-0.85 0.02 0.01" width="1.5"></a-text>
      <a-entity id="thetaSlider"
        ui-slider="min: 30; max: 340; value: 180; width: 1.8; height: 0.14; on: theta; decimals: 0; step: 1; hitpad: 0.25"
        position="0 -0.08 0.01"></a-entity>

      <!-- Computed height readout -->
      <a-text id="heightReadout" value="Computed height: —" color="#ddd" align="center" width="1.8"
        position="0 -0.26 0.01"></a-text>

      <!-- Mode label -->
      <a-text id="modeLabel" value="Mode: Fly" color="#fff" align="center" width="2" position="0 -0.02 0.01"></a-text>

      <!-- Buttons row -->
      <a-entity position="0 -0.38 0.01">
        <a-entity id="btnReset" ui-button="label: Reset View; width: 0.8; height: 0.2" position="-0.45 0 0"></a-entity>
        <a-entity id="btnMode" ui-button="label: Locomotion: Fly; width: 0.95; height: 0.2"
          position="0.55 0 0"></a-entity>
      </a-entity>

      <a-text value="Space / A: Toggle menu • Click or point to interact" color="#ddd" align="center" width="1.8"
        position="0 -0.56 0.01"></a-text>
    </a-entity>
  </a-scene>
</body>

</html>